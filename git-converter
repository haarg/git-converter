#!/usr/bin/env perl
use strictures 1;
use File::Basename qw(dirname);
use Cwd qw(realpath);
use autodie ':all';
use File::chdir;

my $script = realpath(__FILE__);
my $root = dirname($script);

{
  package SVN::Converter;
  use Moo;
  use autodie ':all';
  use Git::Wrapper;
  use File::Basename qw(basename);
  use File::Copy qw(copy);
  use Cwd qw(realpath);
  use JSON qw(encode_json decode_json);
  use Carp;
  use File::chdir;

  sub from_file {
    my $class = shift;
    for my $file ($_[0], "conversions/$_[0]") {
      next
        unless -f $file;
      open my $fh, '<', $file;
      my $content = do { local $/; <$fh> };
      my $info = decode_json($content);
      $info->{name} ||= basename($file);
      my $self = $class->new($info);
      $self->save_config;
      return $self;
    }
    die "bad file: $_[0]\n";
  }

  has name => (is => 'lazy', default => sub { $_[0]->config('name') } );
  has talisman => ( is => 'lazy', default => sub { $_[0]->config('talisman') } );
  has tag_prefix => ( is => 'lazy', default => sub { $_[0]->config('tag_prefix') } );
  has authors => (is => 'lazy', default => sub { $_[0]->config('authors') } );

  has trunk => ( is => 'lazy', default => sub { $_[0]->config('trunk') } );
  for my $type (qw(branch tag)) {
    has "${type}_roots" => (
      is => 'lazy',
      coerce => sub { ref $_[0] ? $_[0] : [ $_[0] ] },
      default => sub { $_[0]->config("${type}_roots") },
    );
  }

  has svn_url => (is => 'lazy', default => sub { $_[0]->config('svn_url') }, coerce => sub {
    my $url = shift;
    return $url
      if $url =~ m{^\w+://};
    for my $try ($url, "mirrors/$url") {
      my @parts = split m{/}, $try;
      for my $i (0..$#parts) {
        if (-d File::Spec->catdir(@parts[0..$i], 'db')) {
          return "file://" . realpath($try);
        }
      }
    }
    die "invalid svn repo $url";
  });
  has repo => (is => 'lazy', default => sub { $_[0]->name }, coerce => sub {
    -d $_[0] ? realpath($_[0]) : -d "repos/$_[0]" ? realpath("repos/$_[0]") : File::Spec->rel2abs("repos/$_[0]")
  } );
  has git => (is => 'lazy', default => sub {
    my $repo = $_[0]->repo;
    my $need_init = !-e $repo;
    mkdir $repo
      if $need_init;
    my $git = Git::Wrapper->new($repo);
    $git->init
      if $need_init;
    $git;
  });
  sub config {
    my ($self, $entry) = @_;
    my $git = $self->git;
    my @values;
    $entry =~ s/_/-/g;
    eval { @values = $git->config({get_all => 1}, "svn-converter.$entry") };
    return (@values > 1 ? \@values : $values[0]);
  }
  sub save_config {
    my $self = shift;
    my $git = $self->git;
    for my $attr (qw(repo tag_roots branch_roots trunk authors talisman tag_prefix svn_url name)) {
      my $value = $self->$attr;
      my $entry = $attr;
      $entry =~ s/_/-/g;
      my @values = grep defined, ref $value ? @$value : $value;
      eval { $git->config({unset_all => 1}, "svn-converter.$entry") };
      for (@values) {
        $git->config({add => 1}, "svn-converter.$entry", $_);
      }
    }
  }
  has grafts => (is => 'lazy', default => sub {
    my $graft_file = $_[0]->repo . '/.git/info/grafts';
    return {}
      unless -e $graft_file;
    open my $fh, '<', $graft_file;
    my @grafts = <$fh>;
    chomp @grafts;
    my %grafts;
    for my $graft (@grafts) {
      next
        if $graft =~ /^\s*(#|$)/;
      my ($commit, @parents) = split /\s+/, $graft;
      $grafts{$commit} = \@parents;
    }
    return \%grafts;
  });
  sub save_grafts {
    my $self = shift;
    my $grafts = $self->grafts;
    open my $fh, '>', realpath($self->repo) . '/.git/info/grafts';
    for my $commit (sort keys %$grafts) {
      print { $fh } join(' ', $commit, @{ $grafts->{$commit} }) . "\n";
    }
    close $fh;
  }
  has simplified_merges => (is => 'lazy', default => sub {
    my $merge_file = $_[0]->repo . '.git/info/simplified-merges';
    return {}
      unless -e $merge_file;
    open my $fh, '<', $merge_file;
    my $content = do { local $/; <$fh> };
    return decode_json($content);
  });
  sub save_simplified_merges {
    my $self = shift;
    my $merges = $self->simplified_merges;
    open my $fh, '>', $self->repo . '/.git/info/simplified_merges';
    print { $fh } encode_json($merges);
    close $fh;
  }
  sub add_simplified_merges {
    my ($self, $merges) = @_;
    my $simplified = $self->simplified_merges;
    my $grafts = $self->grafts;
    for my $merge ( keys %$merges ) {
      $simplified->{$merge} ||= $merges->{$merge};
      $grafts->{$merge} = $merges->{$merge};
    }
    $self->save_simplified_merges;
    $self->save_grafts;
  }

  has authors_file => (is => 'lazy', default => sub {
    my $self = shift;
    my $file = $self->repo."/.git/svn-authors";
    if (!-e $file) {
      if ($self->authors) {
        File::Copy::copy("authors/".$self->authors, $file);
      }
      else {
        open my $fh, '>', $file;
      }
    }
    return realpath($file);
  });

  sub init {
    my $self = shift;

    my $repo = $self->repo;
    my $git = $self->git;
    $git->init;

    my $authors_file = $self->authors_file;
    open my $fh, '>', "$repo/.git/author-generate";
    print { $fh } <<"END_SCRIPT";
#!/bin/sh
SVN_USER=\$1
AUTHOR="\$SVN_USER <\$SVN_USER\@svn-converter>"
echo "\$SVN_USER = \$AUTHOR" >> "$authors_file"
echo "\$AUTHOR"
END_SCRIPT
    close $fh;
    chmod 0755, "$repo/.git/author-generate";

    my @locations;
    push @locations, '--trunk', $self->trunk;
    for my $type (qw(branch tag)) {
      push @locations, map {; "--$type", $_ } @{ $self->${\"${type}_roots"}||[] };
    }


    local $ENV{PERL5LIB};
    $git->svn('init', '--prefix=svn/', @locations, $self->svn_url);
    $git->config('svn.authorsfile', $self->authors_file);
    $git->config('svn.preserve-empty-dirs', 'true');
    $git->config('svn.placeholder-filename', '.gitignore');
  }


  sub svn_info {
    my $url = shift;

    my %info;
    open my $fh, '-|', 'svn', 'info', $url;
    while (my $line = <$fh>) {
      my ($item, $value) = split /:/, $line, 2;
      next unless $value;
      for ($item, $value) {
        s/\s+$//;
        s/^\s+//;
      }
      $info{$item} = $value;
    }

    return %info;
  }

  sub update {
    my $self = shift;
    if ($self->svn_url =~ /^file:/) {
      my %info = svn_info($self->svn_url);
      system 'svnsync', '--non-interactive', 'sync', $info{'Repository Root'};
    }
    my $repo = realpath($self->repo);
    local $ENV{PERL5LIB};
    local $CWD = $repo;
    system 'git', 'svn', 'fetch', "--authors-prog=$repo/.git/author-generate";
  }

  sub branches {
    my $self = shift;
    return [ $self->git->for_each_ref({format=>'%(refname)'}, 'refs/heads/convert/') ];
  }
  sub tags {
    my $self = shift;
    return [ $self->git->for_each_ref({format=>'%(refname)'}, 'refs/tags/convert/') ];
  }
  sub refs {
    my $self = shift;
    return [ $self->git->for_each_ref({format=>'%(refname)'}, 'refs/heads/convert', 'refs/tags/convert/') ];
  }

  sub convert_refs {
    my $self = shift;

    my $git = $self->git;
    my @refs = $git->for_each_ref({format=>'%(refname)'}, 'refs/remotes/svn/');
    for my $ref (@refs) {
      (my $bare = $ref) =~ s{^refs/remotes/svn/}{};
      next
        if $bare =~ /\@/;
      next
        if $bare =~ m{^tags/};
      if (my $talisman = $self->talisman) {
        next
          unless eval { $git->show("$ref:$talisman"); 1 };
      }
      if ($bare eq 'trunk') {
        $bare = 'master';
      }
      $git->update_ref("refs/heads/convert/$bare", $ref);
    }
  }

  sub convert_tags {
    my $self = shift;

    my $git = $self->git;
    my @refs = $git->for_each_ref({format=>'%(refname)'}, 'refs/remotes/svn/tags/');
    for my $ref (@refs) {
      (my $bare = $ref) =~ s{^refs/remotes/svn/tags/}{};
      next
        if $bare =~ /\@/;

      if (my $talisman = $self->talisman) {
        next
          unless eval { $git->show("$ref:$talisman"); 1 };
      }

      my $tag_name = $bare;
      if (my $prefix = $self->tag_prefix) {
        $tag_name =~ s/^$prefix-?//;
      }
      $tag_name =~ s/^v?/v/;

      $self->move_tag("convert/$tag_name", $ref, $ref);
    }
  }

  sub git_svn_id {
    my @commit_message = map { split /\n/, $_ } @_;
    my ($svn_id) = grep { /^git-svn-id:/ } reverse @commit_message;
    return
      unless $svn_id;
    $svn_id =~ s/^git-svn-id:\s+//;
    $svn_id =~ s/\s+(\S+)$//;
    my $uuid = $1;
    $svn_id =~ s/\@(\d+)$//;
    my $rev = $1;
    my $url = $svn_id;
    return ($url, $rev, $uuid);
  }

  sub move_tag {
    my ($self, $tag, $ref, $orig) = @_;
    my $git = $self->git;

    my $commit_message;
    $orig ||= $tag;

    my %header;
    my ($type) = $git->cat_file({t => 1}, $orig);
    for my $line ($git->cat_file($type, $orig)) {
      if (defined $commit_message) {
        $commit_message .= $line . "\n";
      }
      elsif ($line eq '') {
        $commit_message = '';
      }
      else {
        my ($key, $value) = split / /, $line, 2;
        $header{$key} = $value;
      }
    }

    my $user = $header{tagger} || $header{committer};
    $user =~ s/\s+(\d+\s+[-+]?\d+)$//;
    my $date = $1;
    my ($name, $email) = $user =~ /^(.*?)\s+<([^<>]+)>$/;
    ($name, $email) = $self->fix_author($name, $email);

    $commit_message =~ s/^git-svn-id:.*//ms;
    $commit_message =~ s/\n+$//;

    local $ENV{GIT_COMMITTER_NAME} = $name;
    local $ENV{GIT_COMMITTER_EMAIL} = $email;
    local $ENV{GIT_COMMITTER_DATE} = $date;
    $git->tag({ f => 1, a => 1, message => $commit_message }, $tag, $ref);
  }

  sub fix_tags {
    my $self = shift;
    for my $tag (@{ $self->tags }) {
      (my $tag_name = $tag) =~ s{^refs/tags/convert/}{};
      $self->move_tag($tag_name, $tag, $tag);
    }
  }

  sub fix_author {
    my ($self, $name, $email) = @_;
    open my $fh, '<', $self->authors_file;
    while (my $line = <$fh>) {
      if ( $line =~ /(\w+)\s*=\s*(.*?)\s*<([^>]+)>/ ) {
        if ($1 eq $name) {
          return ("$2", "$3");
        }
      }
    }
    return ($name, $email);
  }

  sub log_search {
    my ($self, $search, %opts) = @_;
    return $self->git->RUN('log', {
      format => '%H',
      ($search ? ( 'grep' => $search ) : () ),
      %opts,
    }, @{ $self->refs });
  }

  sub graft_svk_merges {
    my $self = shift;
    my $git = $self->git;
    my @merges = $self->log_search('(orig r', no_merges => 1);

    my $grafts = $self->grafts;

    for my $commit (@merges) {
      my $commit_data = join "\n", $git->cat_file('commit', $commit);
      my @matched = $commit_data =~ /^[ ]r\d+\@[^\n]+\(orig[ ]r(\d+)\)/msxg;
      my ($parent_rev) = sort { $b <=> $a } @matched;
      unless ($parent_rev) {
        @matched = $commit_data =~ /^[ ][ ]r\d+\@[^\n]+\(orig[ ]r(\d+)\)/msxg;
        ($parent_rev) = sort { $b <=> $a } @matched;
        unless ($parent_rev) {
          @matched = $commit_data =~ /^[ ][ ][ ]r\d+\@[^\n]+\(orig[ ]r(\d+)\)/msxg;
          ($parent_rev) = sort { $b <=> $a } @matched;
          unless ($parent_rev) {
            warn "odd commit $commit.  merge but wrong format\n";
            next;
          }
        }
      }
      my @parents = $self->log_search("git-svn-id: .*\@$parent_rev ", 'E' => 1);
      if (@parents > 1) {
        my ($commit_branch) = $commit_data =~ /git-svn-id: ([^@]+)/;
        my @branch_parent_commits = $self->log_search("git-svn-id: $commit_branch\@$parent_rev ");
        if (@branch_parent_commits > 1) {
          @branch_parent_commits = $self->log_search('git-svn-id: .*/trunk\@$parent_rev ');
          unless (@branch_parent_commits == 1) {
            warn "odd commit $commit.  parent rev crosses branches\n";
            next;
          }
        }
        elsif (!@branch_parent_commits) {
          warn "odd commit $commit.  parent rev crosses branches\n";
          next;
        }
        @parents = @branch_parent_commits;
      }
      unless (@parents) {
        warn "can't find parent commit for $commit - r$parent_rev\n";
        next;
      }

      my ($parent) = @parents;

      my $commit_hashes = $git->show({s => 1, format => '%H %P'}, $commit);
      my ($commit_hash, @parent_hashes) = split /\s+/, $commit_hashes;

      if (! grep { $parent eq $_ } @parent_hashes ) {
        $grafts->{$commit_hash} = [@parent_hashes, $parent];
      }
    }
    $self->save_grafts;
  }

  sub merges {
    my $self = shift;
    return [
      map { split / / }
      $self->git->RUN('log', { merges => 1, format => '%H %P' }, @{$self->refs})
    ];
  }
  sub graft_simplified_merges {
    my $self = shift;
    my $git = $self->git;

    my @merges = @{ $self->merges };

    my %altered;
    my %merges;
    for my $merge ( reverse @merges ) {
      my ($commit, @parents) = @$merge;
      $merges{$commit} = \@parents;
      my ( $left_parent, $right_parent ) = @parents;
      # first parent is a merge
      if ( my $left_grandparents = $merges{ $left_parent } ) {
        my @grandparents = $git->show({s => 1, format => '%P'}, $right_parent);
        my ($right_grandparent) = split / /, @grandparents;
        if ($right_grandparent eq $left_grandparents->[1]) {
          $altered{$commit}++;
          $parents[0] = $left_grandparents->[0];
          delete $merges{ $left_parent };
          delete $altered{ $left_parent };
        }
      }
    }

    for my $commit ( keys %altered ) {
      $altered{$commit} = $merges{$commit};
    }
    $self->add_simplified_merges(\%altered);
  }

  sub graft_redundant_merges {
    my $self = shift;
    my $git = $self->git;

    my @merges = @{ $self->merges };

    my %altered;
    my %merges;
    for my $merge ( reverse @merges ) {
      my ($commit, @parents) = @$merge;
      $merges{$commit} = \@parents;
      PARENT: for my $p ( 0 .. 1 ) {
        my $parent = $parents[ $p ];
        my $check_ancest = $parents[ 1 - $p ];
        my $ancest = $merges{ $check_ancest } || next;

        ANCEST: for my $c ( 0 .. 1 ) {
          if ($parent eq $ancest->[ $c ]) {
            $altered{$commit}++;
            $parents[1 - $p] = $ancest->[1 - $c];
            delete $merges{ $check_ancest };
            delete $altered{ $check_ancest };
            last PARENT;
          }
        }
      }
    }

    for my $commit ( keys %altered ) {
      $altered{$commit} = $merges{$commit};
    }
    $self->add_simplified_merges(\%altered);
  }

  sub delete_merged_branches {
    my $self = shift;
    my $git = $self->git;
    my @branches = @{ $self->branches };
    my %remove;
    CHILD: for my $child ( grep { $_ ne 'refs/heads/convert/master' } @branches ) {
      for my $branch ( @{ $self->refs } ) {
        eval {
          $git->merge_base({is_ancestor => 1}, $child, $branch);
          $remove{$child}++;
          next CHILD;
        };
      }
    }
    for my $branch ( keys %remove ) {
      $git->update_ref({d => 1}, $branch);
    }
  }

  sub delete_empty_branches {
    my $self = shift;
    my $git = $self->git;
    my @branches = grep { $_ ne 'refs/heads/convert/master' } @{ $self->branches };
    my %remove;
    CHILD: for my $child ( @branches ) {
      BRANCH: for my $branch ( @{ $self->refs } ) {
        eval {
          my ($base) = $git->merge_base($child, $branch);
          my @trees = $git->RUN('log', {format => '%H'}, "$base..$child");
          my ($base_tree) = $git->rev_parse("$base^{tree}");
          for my $tree (@trees) {
            if ($base_tree ne $tree) {
              next BRANCH;
            }
          }
          $remove{$child}++;
          next CHILD;
        };
      }
    }
    for my $branch ( keys %remove ) {
      $git->update_ref({d => 1}, $branch);
    }
  }

  sub archive_deleted_branches {
    my $self = shift;
    my $git = $self->git;
    my ($branch_location) = @{ $self->branch_roots };

    my $branch_root = $self->svn_url . '/' . $branch_location;

    my @branches = @{ $self->branches };
    for my $branch (@branches) {
      (my $bare = $branch) =~ s{^refs/heads/convert/}{};
      next
        if $bare =~ m{^trash/};
      my $url = "$branch_root/$bare";
      if (! eval { system "svn info $url >/dev/null 2>/dev/null"; 1 }) {
        $git->update_ref("refs/heads/convert/trash/$bare", $branch);
        $git->update_ref({d => 1}, $branch);
      }
    }
  }

  sub bake {
    my $self = shift;
    my $repo = $self->repo;
    my @refs = @{ $self->refs };
    chdir $repo;
    system 'git', 'filter-branch',
      "--tree-filter"     => "$script make-ignores " . $self->repo,
      "--tag-name-filter" => "cat",
      "--msg-filter"      => "$script msg-filter " . $self->repo,
      "--env-filter"      => "eval \$($script calculate-author @{[ $self->repo ]})",
      "--prune-empty",
      "--force",
      "--", @refs,
    ;
  }

  sub filter_message {
    my ($self, $commit, $message) = @_;
    if ($self->simplified_merges->{$commit}) {
      $message = '';
    }
    $message =~ s/\A\s*-\s*([^\n]+)\n*\z/$1/ms;
    my $git = $self->git;
    my ( $to, @from ) = split /\s+/, ($git->show({ s => 1, format => '%P' }, $commit))[0];

    if ( @from ) {
      # print the original message
      $message =~ s/^ //mg;

      return "Merge ",
          join(", ", map { $self->format_branch($_) } @from),
          " into ",
          $self->format_branch($to),
          "\n\n",
          $message;
    }
    else {
      if ( $message =~ s/^\s*r\d+\@.*:.*$//m ) {
        $message =~ s/^ //mg;
      }
      return $message;
    }
  }

  sub format_branch {
    my ($self, $commit) = shift;
    my $git = $self->git;
    my ($svn_id) = git_svn_id($git->show({s => 1, format => '%s%n%n%b'}, $commit));
    my $svn_url = $self->svn_url;
    $svn_id =~ s{^\Q$svn_url\E/?}{};
    my $rev = $1;
    my @roots = ('('.$self->trunk.')', map { "$_/([^/]+)" } @{ $self->branch_roots });
    for my $root (@roots) {
      if ($svn_id =~ /^$root/) {
        return "'$1'";
      }
    }
    if ($rev) {
      return $rev;
    }
    die "unknown rev for $commit";
  }
}

sub run {
  my $class = shift;
  my $command = shift || die "no command";
  my $method = "cmd_$command";
  $method =~ s/-/_/g;
  die "invalid command $command"
    unless $class->can($method);
  $class->$method(@_);
}

sub cmd_mirror {
  my ($class, $mirror_name, $svn_url) = @_;
  die "no mirror name given"
    unless $mirror_name;
  my $svn_mirror = File::Spec->catdir($root, 'mirrors', $mirror_name);
  my $svn_mirror_url = 'file://' . realpath($svn_mirror);
  my %remote_info;
  if ($svn_url) {
    %remote_info = SVN::Converter::svn_info($svn_url);
    $svn_url = $remote_info{'Repository Root'};
  }
  if (-e $svn_mirror) {
    my $current_url = `svn propget --revprop -r 0 svn:sync-from-url $svn_mirror_url`;
    chomp $current_url;
    if ($current_url) {
      if ($current_url ne $svn_url) {
        print "updating url\n";
        system "svn propset --revprop -r 0 svn:sync-from-url $svn_url $svn_mirror_url";
      }
    }
    elsif (!$svn_url) {
      die "mirror exists but not set for sync";
    }
  }
  elsif ($svn_url) {
    system 'svnadmin', 'create', $svn_mirror;
    {
      open my $fh, '>', "$svn_mirror/hooks/pre-revprop-change" or die "$!";
      print { $fh } "#!/bin/sh\n";
      close $fh;
      chmod 0755, "$svn_mirror/hooks/pre-revprop-change";
    }
    system 'svnadmin', 'setuuid', $svn_mirror, $remote_info{'Repository UUID'};
    system 'svnsync', 'init', $svn_mirror_url, $svn_url;
  }
  else {
    die "mirror doesn't exist and no svn url given\n";
  }
  system 'svnsync', '--non-interactive', 'sync', $svn_mirror_url;
}

sub cmd_init {
  my ($class, $file) = @_;
  my $c = SVN::Converter->from_file($file);
  $c->init;
}

sub cmd_update {
  my ($class, $file) = @_;
  my $c = SVN::Converter->new(repo => $file);
  $c->update;
}

sub cmd_convert {
  my ($class, $file) = @_;
  my $c = SVN::Converter->new(repo => $file);
  $c->convert_refs;
  $c->convert_tags;
  $c->graft_svk_merges;
  $c->graft_simplified_merges;
  $c->graft_redundant_merges;
  $c->delete_merged_branches;
  $c->delete_empty_branches;
  $c->bake;
  $c->fix_tags;
}

sub cmd_convert_refs {
  my ($class, $file) = @_;
  my $c = SVN::Converter->new(repo => $file);
  $c->convert_refs;
  $c->convert_tags;
}

sub cmd_svk_merges {
  my ($class, $file) = @_;
  my $c = SVN::Converter->new(repo => $file);
  $c->graft_svk_merges;
}

sub cmd_simplified_merges {
  my ($class, $file) = @_;
  my $c = SVN::Converter->new(repo => $file);
  $c->graft_simplified_merges;
}

sub cmd_redundant_merges {
  my ($class, $file) = @_;
  my $c = SVN::Converter->new(repo => $file);
  $c->graft_redundant_merges;
}

sub cmd_delete_merged {
  my ($class, $file) = @_;
  my $c = SVN::Converter->new(repo => $file);
  $c->delete_merged_branches;
}

sub cmd_delete_empty {
  my ($class, $file) = @_;
  my $c = SVN::Converter->new(repo => $file);
  $c->delete_empty_branches;
}

sub cmd_move_tag {
  my ($class, $file, $tag, $ref) = @_;
  my $c = SVN::Converter->new(repo => $file);
  $c->move_tag($tag, $ref);
}

sub cmd_bake {
  my ($class, $file) = @_;
  my $c = SVN::Converter->new(repo => $file);
  $c->bake;
  $c->fix_tags;
}

sub cmd_fix_tags {
  my ($class, $file) = @_;
  my $c = SVN::Converter->new(repo => $file);
  $c->fix_tags;
}

sub cmd_push {
  my ($class, $file, $url) = @_;
  my $c = SVN::Converter->new(repo => $file);
  my $refs = $c->refs;
  my @spec = map { my $r = $_; $r =~ s{^refs/(heads|tags)/convert/}{refs/$1/}; "$_:$r" } @$refs;
  local $CWD = $c->repo;
  system 'git', 'push', $url, @spec;
}

sub cmd_archive {
  my ($class, $file) = @_;
  my $c = SVN::Converter->new(repo => $file);
  mkdir 'archive';
  my $name = $c->name.'.git';
  system 'git', 'init', '--bare', "archive/$name";
  my $url = realpath("archive/$name");
  $class->cmd_push($file, $url);
  local $CWD = 'archive';
  system 'tar', 'czf', "$name.tar.gz", $name;
  system 'rm', '-rf', $name;
}

sub cmd_make_ignores {
  my ($class, $repo) = @_;
  my $commit = $ENV{GIT_COMMIT};
  if (-e '.gitignore') {
    return;
  }

  my $git = Git::Wrapper->new($repo);
  my ($svn_url) = $git->config('svn-remote.svn.url');
  my ($url, $rev) = SVN::Converter::git_svn_id($git->show({s => 1, format => '%s%n%n%b'}, $commit));
  if ($url) {
    my @ignores;
    my $dir;
    open my $io, '-|', 'svn', 'pg', '-R', 'svn:ignore', "$url\@$rev";
    while (my $line = <$io>) {
      chomp $line;
      my $file = $line;
      if ($line =~ m{^\Q$url\E(\S*) - (\S+)$}) {
        $dir = $1;
        $file = $2;
        $dir =~ s{^/}{};
        $dir =~ s{/?$}{/};
      }
      next
        unless $file;
      $file = "$dir$file";
      $file =~ s{^/}{};
      $file =~ s{/\*$}{/};
      $file =~ s{\b(_build|blib|inc|t/var)/?$}{$1/};
      push @ignores, $file;
    }
    close $io;
    if (@ignores) {
      open my $fh, '>', '.gitignore';
      print {$fh} "$_\n"
        for sort @ignores;
      close $fh;
    }
  }
}

sub cmd_author_generate {
  my ($class, $user) = shift;
  my $author = "$user <$user\@svn-converter>";
  my $repo = Cwd::cwd();
  my $c = SVN::Converter->new(repo => $repo);
  open my $fh, '>>', $c->authors_file;
  print { $fh } "$author\n";
  close $fh;
  print $author . "\n";
}

sub cmd_calculate_author {
  my ($class, $repo) = @_;
  my $commit = $ENV{GIT_COMMIT};
  my $name = $ENV{GIT_AUTHOR_NAME};
  my $email = $ENV{GIT_AUTHOR_EMAIL};

  if ("$name <$email>" eq "$name <$name\@svn-converter>") {
    my $c = SVN::Converter->new(repo => $repo);
    ($name, $email) = $c->fix_author($name, $email);
    print "export GIT_AUTHOR_NAME=$name\n";
    print "export GIT_AUTHOR_EMAIL=$email\n";
    print "export GIT_COMMITTER_NAME=$name\n";
    print "export GIT_COMMITTER_EMAIL=$email\n";

  }
}

sub cmd_msg_filter {
  my ($class, $repo) = @_;
  my $message = do { local $/; <STDIN> };
  print $message;
  my $commit = $ENV{GIT_COMMIT};
  my $c = SVN::Converter->new(repo => $repo);
  print $c->filter_message($commit, $message);
}

__PACKAGE__->run(@ARGV);
exit;

